import numpy as np
from abc import abstractmethod
from uuid import uuid4
from .utils import docval, get_docval, call_docval_func, getargs, ExtenderMeta, get_data_shape
from .data_utils import DataIO
from collections import namedtuple
from warnings import warn
import xarray as xr
import h5py


class AbstractContainer(metaclass=ExtenderMeta):

    # The name of the class attribute that subclasses use to autogenerate properties
    # This parameterization is supplied in case users would like to configure
    # the class attribute name to something domain-specific
    _fieldsname = '__fields__'

    _data_type_attr = 'data_type'

    # Subclasses use this class attribute to add properties to autogenerate
    # Autogenerated properties will store values in self.__field_values
    __fields__ = tuple()

    _pconf_allowed_keys = {'name', 'doc', 'settable'}

    # Override the _setter factor function, so directives that apply to
    # Container do not get used on Data
    @classmethod
    def _setter(cls, field):
        """
        Make a setter function for creating a :py:func:`property`
        """
        name = field['name']

        if not field.get('settable', True):
            return None

        def setter(self, val):
            if val is None:
                return
            if name in self.fields:
                msg = "can't set attribute '%s' -- already set" % name
                raise AttributeError(msg)
            self.fields[name] = val

        return setter

    @classmethod
    def _getter(cls, field):
        """
        Make a getter function for creating a :py:func:`property`
        """
        doc = field.get('doc')
        name = field['name']

        def getter(self):
            return self.fields.get(name)

        setattr(getter, '__doc__', doc)
        return getter

    @staticmethod
    def _check_field_spec(field):
        """
        A helper function for __gather_fields to make sure we are always working
        with a dict specification and that the specification contains the correct keys
        """
        tmp = field
        if isinstance(tmp, dict):
            if 'name' not in tmp:
                raise ValueError("must specify 'name' if using dict in __fields__")
        else:
            tmp = {'name': tmp}
        return tmp

    @ExtenderMeta.pre_init
    def __gather_fields(cls, name, bases, classdict):
        '''
        This classmethod will be called during class declaration in the metaclass to automatically
        create setters and getters for fields that need to be exported
        '''
        fields = getattr(cls, cls._fieldsname)
        if not isinstance(fields, tuple):
            msg = "'%s' must be of type tuple" % cls._fieldsname
            raise TypeError(msg)

        if len(bases) and 'Container' in globals() and issubclass(bases[-1], Container) \
                and getattr(bases[-1], bases[-1]._fieldsname) is not fields:
            new_fields = list(fields)
            new_fields[0:0] = getattr(bases[-1], bases[-1]._fieldsname)
            setattr(cls, cls._fieldsname, tuple(new_fields))
        new_fields = list()
        docs = {dv['name']: dv['doc'] for dv in get_docval(cls.__init__)}
        for f in getattr(cls, cls._fieldsname):
            pconf = cls._check_field_spec(f)
            pname = pconf['name']
            pconf.setdefault('doc', docs.get(pname))
            if not hasattr(cls, pname):
                setattr(cls, pname, property(cls._getter(pconf), cls._setter(pconf)))
            new_fields.append(pname)
        setattr(cls, cls._fieldsname, tuple(new_fields))

    def __new__(cls, *args, **kwargs):
        inst = super().__new__(cls)
        inst.__container_source = kwargs.pop('container_source', None)
        inst.__parent = None
        inst.__children = list()
        inst.__modified = True
        inst.__object_id = kwargs.pop('object_id', str(uuid4()))
        inst.parent = kwargs.pop('parent', None)
        return inst

    @docval({'name': 'name', 'type': str, 'doc': 'the name of this container'})
    def __init__(self, **kwargs):
        name = getargs('name', kwargs)
        if '/' in name:
            raise ValueError("name '" + name + "' cannot contain '/'")
        self.__name = name
        self.__field_values = dict()

    @property
    def name(self):
        '''
        The name of this Container
        '''
        return self.__name

    @docval({'name': 'data_type', 'type': str, 'doc': 'the data_type to search for', 'default': None})
    def get_ancestor(self, **kwargs):
        """
        Traverse parent hierarchy and return first instance of the specified data_type
        """
        data_type = getargs('data_type', kwargs)
        if data_type is None:
            return self.parent
        p = self.parent
        while p is not None:
            if getattr(p, p._data_type_attr) == data_type:
                return p
            p = p.parent
        return None

    @property
    def fields(self):
        return self.__field_values

    @property
    def object_id(self):
        if self.__object_id is None:
            self.__object_id = str(uuid4())
        return self.__object_id

    @property
    def modified(self):
        return self.__modified

    @docval({'name': 'modified', 'type': bool,
             'doc': 'whether or not this AbstractContainer has been modified', 'default': True})
    def set_modified(self, **kwargs):
        modified = getargs('modified', kwargs)
        self.__modified = modified
        if modified and isinstance(self.parent, AbstractContainer):
            self.parent.set_modified()

    @property
    def children(self):
        return tuple(self.__children)

    @docval({'name': 'child', 'type': 'AbstractContainer',
             'doc': 'the child AbstractContainer for this AbstractContainer', 'default': None})
    def add_child(self, **kwargs):
        warn(DeprecationWarning('add_child is deprecated. Set the parent attribute instead.'))
        child = getargs('child', kwargs)
        if child is not None:
            # if child.parent is a Container, then the mismatch between child.parent and parent
            # is used to make a soft/external link from the parent to a child elsewhere
            # if child.parent is not a Container, it is either None or a Proxy and should be set to self
            if not isinstance(child.parent, AbstractContainer):
                # actually add the child to the parent in parent setter
                child.parent = self
        else:
            warn('Cannot add None as child to a container %s' % self.name)

    @classmethod
    def type_hierarchy(cls):
        return cls.__mro__

    @property
    def container_source(self):
        '''
        The source of this Container
        '''
        return self.__container_source

    @container_source.setter
    def container_source(self, source):
        if self.__container_source is not None:
            raise Exception('cannot reassign container_source')
        self.__container_source = source

    @property
    def parent(self):
        '''
        The parent Container of this Container
        '''
        # do it this way because __parent may not exist yet (not set in constructor)
        return getattr(self, '_AbstractContainer__parent', None)

    @parent.setter
    def parent(self, parent_container):
        if self.parent is parent_container:
            return

        if self.parent is not None:
            if isinstance(self.parent, AbstractContainer):
                raise ValueError(('Cannot reassign parent to: %s. Parent is already: %s.'
                                  % (repr(self), repr(self.parent))))
            else:
                if parent_container is None:
                    raise ValueError("Got None for parent of '%s' - cannot overwrite Proxy with NoneType" % repr(self))
                # TODO this assumes isinstance(parent_container, Proxy) but
                # circular import if we try to do that. Proxy would need to move
                # or Container extended with this functionality in build/map.py
                if self.parent.matches(parent_container):
                    self.__parent = parent_container
                    parent_container.__children.append(self)
                    parent_container.set_modified()
                else:
                    self.__parent.add_candidate(parent_container)
        else:
            self.__parent = parent_container
            if isinstance(parent_container, AbstractContainer):
                parent_container.__children.append(self)
                parent_container.set_modified()


class Container(AbstractContainer):

    @docval({'name': 'name', 'type': str, 'doc': 'the name of this container'})
    def __init__(self, **kwargs):
        call_docval_func(super().__init__, kwargs)
        # dict of active dimension names, where key is name of data array and value is a list of names, one per axis
        self.__dims = dict()
        # dict of dimension coordinates, where key is name of data array and value is a list of label-dataset pairs
        self.__coords = dict()

    _pconf_allowed_keys = {'name', 'child', 'required_name', 'doc', 'settable'}

    @classmethod
    def _setter(cls, field):
        super_setter = AbstractContainer._setter(field)
        ret = [super_setter]
        if isinstance(field, dict):
            for k in field.keys():
                if k not in cls._pconf_allowed_keys:
                    msg = "Unrecognized key '%s' in __field__ config '%s' on %s" % (k, field['name'], cls.__name__)
                    raise ValueError(msg)
            if field.get('required_name', None) is not None:
                name = field['required_name']
                idx1 = len(ret) - 1

                def container_setter(self, val):
                    if val is not None and val.name != name:
                        msg = "%s field on %s must be named '%s'" % (field['name'], self.__class__.__name__, name)
                        raise ValueError(msg)
                    ret[idx1](self, val)

                ret.append(container_setter)
            if field.get('child', False):
                idx2 = len(ret) - 1

                def container_setter(self, val):
                    ret[idx2](self, val)
                    if val is not None:
                        if isinstance(val, (tuple, list)):
                            pass
                        elif isinstance(val, dict):
                            val = val.values()
                        else:
                            val = [val]
                        for v in val:
                            if not isinstance(v.parent, Container):
                                v.parent = self
                            # else, the ObjectMapper will create a link from self (parent) to v (child with existing
                            # parent)

                ret.append(container_setter)
        return ret[-1]

    def __repr__(self):
        cls = self.__class__
        template = "%s %s.%s at 0x%d" % (self.name, cls.__module__, cls.__name__, id(self))
        if len(self.fields):
            template += "\nFields:\n"
        for k in sorted(self.fields):  # sorted to enable tests
            v = self.fields[k]
            # if isinstance(v, DataIO) or not hasattr(v, '__len__') or len(v) > 0:
            if hasattr(v, '__len__'):
                if isinstance(v, (np.ndarray, list, tuple)):
                    if len(v) > 0:
                        template += "  {}: {}\n".format(k, self.__smart_str(v, 1))
                elif v:
                    template += "  {}: {}\n".format(k, self.__smart_str(v, 1))
            else:
                template += "  {}: {}\n".format(k, v)
        return template

    @staticmethod
    def __smart_str(v, num_indent):
        """
        Print compact string representation of data.

        If v is a list, try to print it using numpy. This will condense the string
        representation of datasets with many elements. If that doesn't work, just print the list.

        If v is a dictionary, print the name and type of each element

        If v is a set, print it sorted

        If v is a neurodata_type, print the name of type

        Otherwise, use the built-in str()
        Parameters
        ----------
        v

        Returns
        -------
        str

        """

        if isinstance(v, list) or isinstance(v, tuple):
            if len(v) and isinstance(v[0], AbstractContainer):
                return Container.__smart_str_list(v, num_indent, '(')
            try:
                return str(np.asarray(v))
            except ValueError:
                return Container.__smart_str_list(v, num_indent, '(')
        elif isinstance(v, dict):
            return Container.__smart_str_dict(v, num_indent)
        elif isinstance(v, set):
            return Container.__smart_str_list(sorted(list(v)), num_indent, '{')
        elif isinstance(v, AbstractContainer):
            return "{} {}".format(getattr(v, 'name'), type(v))
        else:
            return str(v)

    @staticmethod
    def __smart_str_list(l, num_indent, left_br):
        if left_br == '(':
            right_br = ')'
        if left_br == '{':
            right_br = '}'
        if len(l) == 0:
            return left_br + ' ' + right_br
        indent = num_indent * 2 * ' '
        indent_in = (num_indent + 1) * 2 * ' '
        out = left_br
        for v in l[:-1]:
            out += '\n' + indent_in + Container.__smart_str(v, num_indent + 1) + ','
        if l:
            out += '\n' + indent_in + Container.__smart_str(l[-1], num_indent + 1)
        out += '\n' + indent + right_br
        return out

    @staticmethod
    def __smart_str_dict(d, num_indent):
        left_br = '{'
        right_br = '}'
        if len(d) == 0:
            return left_br + ' ' + right_br
        indent = num_indent * 2 * ' '
        indent_in = (num_indent + 1) * 2 * ' '
        out = left_br
        keys = sorted(list(d.keys()))
        for k in keys[:-1]:
            out += '\n' + indent_in + Container.__smart_str(k, num_indent + 1) + ' ' + str(type(d[k])) + ','
        if keys:
            out += '\n' + indent_in + Container.__smart_str(keys[-1], num_indent + 1) + ' ' + str(type(d[keys[-1]]))
        out += '\n' + indent + right_br
        return out

    @property
    def dims(self):
        '''
        Return a dict of dimension names, indexed by data array name, for this Container. Each value is a list of
        names, one for each dimension of the array.
        '''
        return self.__dims

    @docval({'name': 'data_name', 'type': str, 'doc': ''},
            {'name': 'dim', 'type': str, 'doc': ''})
    def _get_dim_axis(self, **kwargs):
        """Return the axis corresponding to the given dimension of the given array."""
        # TODO updateme
        data_name, dim = getargs('data_name', 'dim', kwargs)
        if data_name not in self.fields:
            raise ValueError("No field named '%s' in %s." % (data_name, self.__class__.__name__))
        if data_name not in self.dims:
            return None  # TODO should this return None or raise an error?
        try:
            axis = self.dims[data_name].index(dim)
        except ValueError:
            raise ValueError("Dim name '%s' not found for field '%s' of %s."
                             % (dim, data_name, self.__class__.__name__))
        return axis

    @docval({'name': 'array_name', 'type': str, 'doc': ''},
            {'name': 'dims', 'type': tuple, 'doc': ''})
    def set_dims(self, **kwargs):
        """
        Set a coordinate between an axis/axes of a given array and an axis/axes of another array in this Container.

        This should be used only internally within PyNWB. User-defined dimensions will not be saved.
        """
        array_name, dims = getargs('array_name', 'dims', kwargs)
        if array_name not in self.fields:
            raise ValueError("Field named '%s' not found in %s '%s'."
                             % (array_name, self.__class__.__name__, self.name))
        if array_name in self.dims:
            raise ValueError("Cannot reset dims for field '%s' in %s '%s'. Dims is already %s."
                             % (array_name, self.__class__.__name__, self.name, self.dims[array_name]))
        if not Container.__all_unique(dims):
            raise ValueError("Cannot set dims for field '%s' in %s '%s'. Dim names must be unique."
                             % (array_name, self.__class__.__name__, self.name))

        data = getattr(self, array_name)
        data_shape = get_data_shape(data)
        if data_shape is None:
            raise ValueError("Cannot determine shape of field '%s' in %s '%s'."
                             % (array_name, self.__class__.__name__, self.name))
        if len(data_shape) != len(dims):
            raise ValueError("Number of dims must equal number of axes for field '%s' in %s '%s' (%d != %d)."
                             % (array_name, self.__class__.__name__, self.name, len(dims), len(data_shape)))

        self.dims[array_name] = dims

    @staticmethod
    def __all_unique(x):
        """Return whether all elements in the given iterable are unique."""
        seen = set()
        return not any(i in seen or seen.add(i) for i in x)

    @property
    def coords(self):
        """
        Return a dictionary of coordinates, indexed by array name, for this Container. Each value is a dictionary of
        coordinates, indexed by label, where the value is a tuple: (tuple of dimension names, the coordinate array).
        """
        return self.__coords

    @docval({'name': 'array_name', 'type': str, 'doc': ''},
            {'name': 'name', 'type': str, 'doc': ''},
            {'name': 'dims_index', 'type': tuple, 'doc': ''},
            {'name': 'coord_array_name', 'type': str, 'doc': ''},
            {'name': 'coord_array_dims_index', 'type': tuple, 'doc': ''},
            {'name': 'coord_type', 'type': str, 'doc': ''})
    def set_coord(self, **kwargs):
        """
        Set a coordinate between an axis/axes of a given array and an axis/axes of another array in this Container.

        This should be used only internally within PyNWB. User-defined coordinates will not be saved.

        Usage examples:
        Field 'data' has dim 'time' for axis 0, 'electrodes' for axis 1.
        Field 'timestamps' has cooordinates for axis 0 of data and length equal to data.shape[0].
        set_coord(array_name='data', name='my_time', dims_index=(0, ), coord_array_name='timestamps',
                  coord_array_dims_index=(0, ), coord_type='aligned')
        will result in:
        self.coords['data']['my_time'] == Coordinates.Coord(name='my_time', dims=('time', ),
                                                            coord_array_name='timestamps', coord_array_dims_index=(0, ),
                                                            coord_type='aligned')

        Field 'data' has dim 'frame' for axis 0, 'x' for axis 1, and 'y' for axis 2.
        Field 'dorsal_ventral' is a coordinate for axes 1 and 2 of data.
        set_coord(array_name='data', name='dv', dims_index=(1, 2), coord_array_name='dorsal_ventral',
                  coord_array_dims_index=(0, 1), coord_type='aligned')
        will result in:
        self.coords['data']['dv'] == Coordinates.Coord(name='dv', dims=('x', 'y'),
                                                       coord_array_name='dorsal_ventral', coord_array_dims_index=(0, 1),
                                                       coord_type='aligned')
        """
        array_name, name, dims_index, = getargs('array_name', 'name', 'dims_index', kwargs)
        coord_array_name, coord_array_dims_index, coord_type = getargs('coord_array_name', 'coord_array_dims_index',
                                                                       'coord_type', kwargs)
        if array_name not in self.fields:
            raise ValueError("Cannot set coord '%s'. Field name '%s' not found in %s '%s'."
                             % (name, array_name, self.__class__.__name__, self.name))
        if array_name not in self.dims:
            raise ValueError("Cannot set coord '%s'. No dimensions have been specified for '%s' in %s '%s'."
                             % (name, array_name, self.__class__.__name__, self.name))
        if coord_array_name not in self.fields:
            raise ValueError("Cannot set coord '%s'. Field name '%s' not found in %s '%s'."
                             % (name, coord_array_name, self.__class__.__name__, self.name))
        if array_name == coord_array_name:
            raise ValueError("Cannot set coord '%s' to itself: %s" % (name, array_name))
        if len(dims_index) != len(coord_array_dims_index):
            raise ValueError("Cannot set coord '%s'. Number of specified dimension indices must equal number of "
                             "specified coord array dimension indices (%d != %d)."
                             % (name, len(dims_index), len(coord_array_dims_index)))

        data = getattr(self, array_name)
        data_shape = get_data_shape(data)
        coord_data = getattr(self, coord_array_name)
        coord_shape = get_data_shape(coord_data)

        if coord_type == 'aligned':
            for daxis, caxis in zip(dims_index, coord_array_dims_index):
                if data_shape[daxis] != coord_shape[caxis]:
                    raise ValueError(("Cannot set coord '%s'. Dimension index %d of array '%s' must have the same "
                                      "length as dimension index %d of array '%s' in %s '%s' (%d != %d).")
                                     % (name, daxis, array_name, caxis, coord_data, self.__class__.__name__, self.name,
                                        data_shape[daxis], coord_shape[caxis]))
        else:
            raise ValueError("Cannot set coord '%s'. Unknown coord type: %s" % (name, coord_type))

        if array_name not in self.coords:
            self.coords[array_name] = Coordinates(parent=self)  # initialize for this array

        dims = list()
        for dims_ind in dims_index:
            dims.append(self.dims[array_name][dims_ind])  # get dim names

        self.coords[array_name].add(name=name, dims=tuple(dims), coord_array=coord_data,
                                    coord_array_dims_index=coord_array_dims_index, coord_type=coord_type)

    @docval({'name': 'array_name', 'type': str, 'doc': ''})
    def to_xarray_dataarray(self, **kwargs):
        """Return an xarray.DataArray for the given array in this Container, with dims and coords set."""
        array_name = getargs('array_name', kwargs)
        if array_name not in self.fields:
            raise ValueError("Field name '%s' not found in %s '%s'." % (array_name, self.__class__.__name__, self.name))

        xr_kwargs = dict()
        if array_name in self.dims:
            xr_kwargs['dims'] = self.dims[array_name]

        if array_name in self.coords:
            # convert the Coordinates dictionary of Coordinate.Coord objs into an xarray coords dictionary of tuples
            xr_coords = dict()
            for coord in self.coords[array_name].values():
                coord_array = coord.coord_array
                coord_array_shape = get_data_shape(coord_array)
                if len(coord.dims) != len(coord_array_shape):
                    raise ValueError("Cannot convert the array '%s' to an xarray.DataArray. All coordinate arrays "
                                     "must map all of their dimensions to a set of dimensions on '%s'."
                                     % (array_name, array_name))
                xr_coords[coord.name] = (coord.dims, coord_array)
            xr_kwargs['coords'] = xr_coords

        arr = xr.DataArray(getattr(self, array_name), **xr_kwargs)
        return arr

    @docval({'name': 'array_name', 'type': str, 'doc': ''})
    def to_xarray_dataset(self, **kwargs):
        """Return an xarray.Dataset of all of the labeled arrays in this Container."""
        raise NotImplementedError()


class Data(AbstractContainer):
    """
    A class for representing dataset containers
    """

    @docval({'name': 'name', 'type': str, 'doc': 'the name of this container'},
            {'name': 'data', 'type': ('array_data', 'data'), 'doc': 'the source of the data'})
    def __init__(self, **kwargs):
        call_docval_func(super().__init__, kwargs)
        self.__data = getargs('data', kwargs)

    @property
    def data(self):
        return self.__data

    @property
    def shape(self):
        """
        Get the shape of the data represented by this container
        :return: Shape tuple
        :rtype: tuple of ints
        """
        return get_data_shape(self.__data)

    @docval({'name': 'dataio', 'type': DataIO, 'doc': 'the DataIO to apply to the data held by this Data'})
    def set_dataio(self, **kwargs):
        """
        Apply DataIO object to the data held by this Data object
        """
        dataio = getargs('dataio', kwargs)
        dataio.data = self.__data
        self.__data = dataio

    def __bool__(self):
        return len(self.data) != 0

    def __len__(self):
        return len(self.__data)

    def __getitem__(self, args):
        if isinstance(self.data, (tuple, list)) and isinstance(args, (tuple, list)):
            return [self.data[i] for i in args]
        return self.data[args]

    def append(self, arg):
        if isinstance(self.data, list):
            self.data.append(arg)
        elif isinstance(self.data, np.ndarray):
            self.__data = np.append(self.__data, [arg])
        elif isinstance(self.data, h5py.Dataset):
            shape = list(self.__data.shape)
            shape[0] += 1
            self.__data.resize(shape)
            self.__data[-1] = arg
        else:
            msg = "Data cannot append to object of type '%s'" % type(self.__data)
            raise ValueError(msg)

    def extend(self, arg):
        if isinstance(self.data, list):
            self.data.extend(arg)
        elif isinstance(self.data, np.ndarray):
            self.__data = np.append(self.__data, [arg])
        elif isinstance(self.data, h5py.Dataset):
            shape = list(self.__data.shape)
            shape[0] += len(arg)
            self.__data.resize(shape)
            self.__data[-len(arg):] = arg
        else:
            msg = "Data cannot extend object of type '%s'" % type(self.__data)
            raise ValueError(msg)


class DataRegion(Data):

    @property
    @abstractmethod
    def data(self):
        '''
        The target data that this region applies to
        '''
        pass

    @property
    @abstractmethod
    def region(self):
        '''
        The region that indexes into data e.g. slice or list of indices
        '''
        pass


class Coordinates:
    """A dictionary-like object that holds coordinate data (Coord namedtuple value) by name (string key)."""
    # use composition of a dict instead of inheritance to restrict user's ability to use arbitrary dict methods
    # values in this dict cannot be changed once set

    Coord = namedtuple('Coord', ['name', 'dims', 'coord_array', 'coord_array_dims_index', 'coord_type'])

    @docval({'name': 'parent', 'type': Container, 'doc': 'parent container of the coordinate'})
    def __init__(self, **kwargs):
        self.__parent = kwargs['parent']
        self.__dict = dict()

    @docval({'name': 'name', 'type': str, 'doc': 'coordinate name'},
            {'name': 'dims', 'type': tuple, 'doc': 'tuple of dimension names to which the coordinate applies'},
            {'name': 'coord_array', 'type': ('data', 'array_data'), 'doc': 'coordinate data array'},
            {'name': 'coord_array_dims_index', 'type': tuple,
             'doc': 'tuple of dimension indices (0-indexed) of coordinate data array'},
            {'name': 'coord_type', 'type': str, 'doc': 'coordinate type'})
    def add(self, **kwargs):
        name = kwargs['name']
        if name in self.__dict:
            msg = "Coordinate '%s' already exists. Cannot overwrite values in %s." % (name, self.__class__.__name__)
            raise ValueError(msg)
        self.__dict[name] = Coordinates.Coord(**kwargs)

    def __getitem__(self, key):
        return self.__dict[key]

    def __repr__(self):
        return repr(self.__dict)

    def __len__(self):
        return len(self.__dict)

    def __contains__(self, item):
        return item in self.__dict

    def __iter__(self):
        return iter(self.__dict)

    def keys(self):
        return self.__dict.keys()

    def values(self):
        return self.__dict.values()

    def items(self):
        return self.__dict.items()

    def __eq__(self, other):
        return self.__dict == other.__dict and self.__parent == other.__parent

    @property
    def parent(self):
        return self.__parent
